# 订单详细商品选择二级菜单改进方案

## 一、现状分析

### 当前实现

在订单详细编辑界面（`OrderDetailsDialog` 和 `OrderFormDialog`），商品选择使用的是 `OrderDetailRows` 组件，该组件显示一个简单的下拉菜单（Select），直接列出所有库存商品：

```tsx
<Select value={row.inventoryId}>
  <MenuItem value={0}>请选择</MenuItem>
  {inventories
    .filter((inv) => inv.stockQuantity > 0)
    .map((inv) => (
      <MenuItem key={inv.id} value={inv.id}>
        {inv.productName}（库存：{inv.stockQuantity}）
      </MenuItem>
    ))}
</Select>
```

### 问题

- 当商品数量多时，下拉菜单会很长，不易查找
- 没有按分类组织，用户体验不佳
- 不符合 README.md 中的设计规格要求（二级菜单结构）

## 二、改进目标

按照 README.md 第 290-320 行的设计规格，实现二级菜单结构：

**第一级**: 商品分类（来自分类表）

- 电子产品
- 服装
- 食品

**第二级**: 商品名 + 在库数量（仅显示在库数量 > 0 的记录）

- 电子产品
  - iPhone 14 (库存: 50)
  - iPad Pro (库存: 30)
  - MacBook Air (库存: 20)

**交互流程**:

1. 点击商品名下拉框 → 展开分类列表
2. 选择分类 → 展开该分类下的商品列表
3. 选择商品 → 进货单价自动填充，焦点跳转到"数量"输入框
4. 输入数量 → 实时校验是否超过库存，超过则标红

## 三、技术方案

### 3.1 数据准备

#### 后端 API

- ✅ 已有：`GET /api/categories` - 获取所有分类
- ✅ 已有：`GET /api/inventory` - 获取库存列表（包含 `productName` 和关联的 `product.categoryId`）

需要确认：

- Inventory API 返回的数据是否包含 `categoryId` 和 `categoryName`
- 如果没有，需要在后端 DTO 中添加这些字段

#### 前端数据加载

在订单页面（`orders/page.tsx`）中：

```tsx
// 已有
const { inventories, loadAllInventories } = useInventory();

// 新增
const { categories, loadCategories } = useCategories();

useEffect(() => {
  loadOrders().catch(() => setError('加载订单列表失败'));
  loadAllInventories().catch(() => setError('加载库存列表失败'));
  loadCategories().catch(() => setError('加载分类列表失败')); // 新增
}, [loadOrders, loadAllInventories, loadCategories]);
```

### 3.2 UI 组件改造

#### 方案 A：使用 Material-UI 嵌套菜单（推荐）

使用 `<Select>` 配合 `<ListSubheader>` 实现分组效果：

```tsx
<Select value={row.inventoryId}>
  <MenuItem value={0}>请选择</MenuItem>
  {categories.map((category) => [
    <ListSubheader key={`header-${category.id}`}>{category.name}</ListSubheader>,
    ...inventories
      .filter((inv) => inv.stockQuantity > 0 && inv.product?.categoryId === category.id)
      .map((inv) => (
        <MenuItem key={inv.id} value={inv.id} sx={{ pl: 4 }}>
          {inv.productName}（库存：{inv.stockQuantity}）
        </MenuItem>
      )),
  ])}
</Select>
```

**优点**：

- 实现简单，使用 MUI 原生组件
- 保持与现有 UI 风格一致
- 无需额外依赖

**缺点**：

- 不是真正的二级菜单，只是分组显示
- 所有商品仍然在一个下拉列表中

#### 方案 B：使用 Autocomplete 组件

使用 MUI 的 `<Autocomplete>` 组件，支持分组和搜索：

```tsx
<Autocomplete
  value={selectedInventory}
  onChange={(event, newValue) => {
    if (newValue) {
      onUpdateRow(row.tempId, 'inventoryId', newValue.id);
    }
  }}
  options={inventories.filter((inv) => inv.stockQuantity > 0)}
  groupBy={(option) => option.categoryName || '未分类'}
  getOptionLabel={(option) => `${option.productName}（库存：${option.stockQuantity}）`}
  renderInput={(params) => <TextField {...params} label="选择商品" size="small" />}
/>
```

**优点**：

- 支持分组显示
- 支持搜索/过滤功能
- 用户体验更好

**缺点**：

- 需要维护 `selectedInventory` 状态
- 代码改动较大

#### 方案 C：自定义两级联动下拉菜单

第一个下拉框选分类，第二个下拉框显示该分类下的商品：

```tsx
<Box sx={{ display: 'flex', gap: 1 }}>
  <FormControl size="small" sx={{ minWidth: 120 }}>
    <Select
      value={selectedCategoryId}
      onChange={(e) => setSelectedCategoryId(Number(e.target.value))}
    >
      <MenuItem value={0}>全部分类</MenuItem>
      {categories.map((cat) => (
        <MenuItem key={cat.id} value={cat.id}>
          {cat.name}
        </MenuItem>
      ))}
    </Select>
  </FormControl>

  <FormControl size="small" sx={{ flex: 1 }}>
    <Select
      value={row.inventoryId}
      onChange={(e) => onUpdateRow(row.tempId, 'inventoryId', Number(e.target.value))}
    >
      <MenuItem value={0}>请选择商品</MenuItem>
      {inventories
        .filter(
          (inv) =>
            inv.stockQuantity > 0 &&
            (selectedCategoryId === 0 || inv.product?.categoryId === selectedCategoryId)
        )
        .map((inv) => (
          <MenuItem key={inv.id} value={inv.id}>
            {inv.productName}（库存：{inv.stockQuantity}）
          </MenuItem>
        ))}
    </Select>
  </FormControl>
</Box>
```

**优点**：

- 符合"二级菜单"的字面理解
- 可以快速过滤商品

**缺点**：

- 需要两次点击
- 占用更多空间
- 需要为每一行维护分类选择状态

### 3.3 推荐方案

**推荐使用方案 B（Autocomplete）**，理由如下：

1. **最符合设计意图**：虽然不是传统的两级下拉，但提供了按分类组织的清晰视图
2. **用户体验最佳**：支持搜索、分组显示，当商品数量多时尤其有用
3. **实现合理**：使用 MUI 标准组件，代码可维护性高
4. **扩展性好**：未来可以轻松添加更多功能（如显示图片、高级搜索等）

## 四、实施计划

### 4.1 后端改造（如需要）

**检查点**：

- [ ] 确认 `InventoryDto` 是否包含 `categoryId` 和 `categoryName`
- [ ] 如不包含，修改 `InventoryService` 和 `InventoryDto`，在查询时 Include Product.Category

**文件涉及**：

- `InventoryHub.API/DTOs/InventoryDto.cs`
- `InventoryHub.API/Services/InventoryService.cs`
- `InventoryHub.API/Mappings/MappingProfile.cs`

### 4.2 前端改造

#### 步骤 1: 更新类型定义（如需要）

**文件**: `inventory-hub-frontend/types/index.ts`

```typescript
export interface Inventory extends BaseEntity {
  // ...existing fields
  categoryId?: number; // 新增
  categoryName?: string; // 新增
}
```

#### 步骤 2: 在订单页面加载分类数据

**文件**: `inventory-hub-frontend/app/orders/page.tsx`

```typescript
import { useCategories } from '../categories/hooks/useCategories';

export default function OrdersPage() {
  const { categories, loadCategories } = useCategories();

  useEffect(() => {
    loadOrders().catch(() => setError('加载订单列表失败'));
    loadAllInventories().catch(() => setError('加载库存列表失败'));
    loadCategories().catch(() => setError('加载分类列表失败'));
  }, [loadOrders, loadAllInventories, loadCategories]);

  // 传递 categories 到对话框组件
  // <OrderFormDialog ... categories={categories} />
  // <OrderDetailsDialog ... categories={categories} />
}
```

#### 步骤 3: 创建新的商品选择组件

**文件**: `inventory-hub-frontend/app/orders/components/InventorySelect.tsx`（新建）

使用 Autocomplete 实现分组商品选择：

```tsx
'use client';

import { Autocomplete, TextField } from '@mui/material';
import { Inventory } from '@/types';

interface Props {
  value: number;
  inventories: Inventory[];
  onChange: (inventoryId: number, inventory: Inventory | null) => void;
  error?: boolean;
}

export default function InventorySelect({ value, inventories, onChange, error }: Props) {
  const selectedInventory = inventories.find((inv) => inv.id === value) || null;
  const availableInventories = inventories.filter((inv) => inv.stockQuantity > 0);

  return (
    <Autocomplete
      value={selectedInventory}
      onChange={(event, newValue) => {
        onChange(newValue?.id || 0, newValue);
      }}
      options={availableInventories}
      groupBy={(option) => option.categoryName || '未分类'}
      getOptionLabel={(option) => `${option.productName}（库存：${option.stockQuantity}）`}
      renderInput={(params) => (
        <TextField {...params} size="small" error={error} placeholder="选择商品" />
      )}
      isOptionEqualToValue={(option, value) => option.id === value.id}
      noOptionsText="暂无可用库存"
      fullWidth
    />
  );
}
```

#### 步骤 4: 修改 OrderDetailRows 组件

**文件**: `inventory-hub-frontend/app/orders/components/OrderDetailRows.tsx`

```tsx
import InventorySelect from './InventorySelect';

// 替换原来的 Select 组件
<TableCell>
  <InventorySelect
    value={row.inventoryId}
    inventories={inventories}
    onChange={(inventoryId, inventory) => {
      onUpdateRow(row.tempId, 'inventoryId', inventoryId);
    }}
    error={row.inventoryId === 0}
  />
</TableCell>;
```

#### 步骤 5: 更新对话框组件传递 categories

**文件**:

- `inventory-hub-frontend/app/orders/components/OrderFormDialog.tsx`
- `inventory-hub-frontend/app/orders/components/OrderDetailsDialog.tsx`

添加 `categories` props（虽然 Autocomplete 方案不直接使用，但为未来扩展保留）

### 4.3 测试要点

- [ ] 分类列表正确显示
- [ ] 商品按分类分组显示
- [ ] 搜索功能正常（输入商品名可过滤）
- [ ] 选择商品后单价自动填充
- [ ] 库存数量正确显示
- [ ] 库存不足时显示红色警告
- [ ] 只显示库存大于 0 的商品
- [ ] 未分类商品显示在"未分类"组

## 五、影响范围

### 后端

- `InventoryDto.cs` - 可能需要添加 categoryId/categoryName
- `InventoryService.cs` - 可能需要 Include category 信息
- `MappingProfile.cs` - 可能需要更新映射配置

### 前端

- `types/index.ts` - 可能需要更新 Inventory 接口
- `orders/page.tsx` - 加载分类数据
- `orders/components/OrderFormDialog.tsx` - 传递 categories
- `orders/components/OrderDetailsDialog.tsx` - 传递 categories
- `orders/components/OrderDetailRows.tsx` - 替换 Select 为 InventorySelect
- `orders/components/InventorySelect.tsx` - 新建组件

## 六、时间估算

- 后端改造（如需要）：0.5 小时
- 前端组件开发：1-1.5 小时
- 测试和调试：0.5 小时
- **总计**：2-2.5 小时

## 七、备选方案对比

| 方案                  | 实现难度   | 用户体验   | 可维护性   | 扩展性     | 推荐度     |
| --------------------- | ---------- | ---------- | ---------- | ---------- | ---------- |
| A. ListSubheader 分组 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐     | ⭐⭐⭐⭐   | ⭐⭐       | ⭐⭐⭐     |
| B. Autocomplete       | ⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| C. 两级联动 Select    | ⭐⭐⭐     | ⭐⭐⭐     | ⭐⭐⭐     | ⭐⭐⭐     | ⭐⭐       |

## 八、总结

**推荐实施方案 B（Autocomplete 组件）**，这个方案：

1. 提供最佳用户体验（分组 + 搜索）
2. 使用 MUI 标准组件，代码可维护性高
3. 符合现代 Web 应用的交互模式
4. 为未来功能扩展留有余地

该方案在保持代码简洁的同时，提供了优于设计文档中"二级菜单"描述的用户体验。
