# 库存明细引用检查功能说明

## 功能概述

实现了基于订单引用状态的库存明细部分编辑功能。系统会自动检测哪些库存记录已被订单引用，并根据引用状态控制编辑权限：

- **已引用的库存**（灰色背景）：不可修改、不可删除，保护订单数据的完整性
- **未引用的库存**（白色背景）：可以正常编辑和删除

## 实现细节

### 后端修改 (ASP.NET Core)

#### 1. DTO 更新 (`InventoryDto.cs`)
```csharp
public class InventoryDto
{
    // ... 其他字段
    public bool IsReferenced { get; set; }  // 新增：是否被订单引用
}
```

#### 2. 服务层更新 (`InventoryService.cs`)

**GetAllAsync 方法**：
- 批量查询所有库存记录被 OrderDetails 引用的情况
- 使用 `Distinct()` 优化查询性能
- 为每条库存记录设置 `IsReferenced` 标志

**GetByIdAsync 方法**：
- 检查单条库存记录是否被引用
- 使用 `AnyAsync()` 高效判断

**UpdateAsync 方法**：
- 在更新前检查是否被引用
- 如果被引用，抛出 `InvalidOperationException`
- 错误消息：`"该库存已被订单引用，无法修改"`

**DeleteAsync 方法**：
- 在删除前检查是否被引用
- 如果被引用，抛出 `InvalidOperationException`
- 错误消息：`"该库存已被订单引用，无法删除"`

#### 3. 控制器 (`InventoryController.cs`)
- 已有的 PUT 和 DELETE 端点直接复用
- 捕获 `InvalidOperationException` 并返回 400 Bad Request

### 前端修改 (Next.js + TypeScript)

#### 1. 类型定义更新 (`types/index.ts`)

**Inventory 接口**：
```typescript
export interface Inventory extends BaseEntity {
  // ... 其他字段
  isReferenced: boolean;  // 新增
}
```

**InventoryRow 接口**：
```typescript
export interface InventoryRow extends CreateInventory {
  tempId: string;
  id?: number;              // 新增：数据库ID
  isReferenced?: boolean;   // 新增：引用状态
  // ... 其他字段
}
```

#### 2. Hooks 更新 (`useInventory.ts`)

新增方法：
```typescript
const updateInventory = async (id: number, data: CreateInventory) => {
  const res = await api.put(`/inventory/${id}`, data);
  await loadAllInventories();
  return res.data;
};

const deleteInventory = async (id: number) => {
  await api.delete(`/inventory/${id}`);
  await loadAllInventories();
};
```

#### 3. 页面逻辑更新 (`page.tsx`)

**加载数据时**：
- 将后端返回的 `isReferenced` 字段保存到 `InventoryRow`
- 保留数据库 `id` 以便后续更新/删除操作

**保存逻辑**：
- 区分新行和已存在的行
- 新行使用 `createBatch` 批量创建
- 已存在的未引用行使用 `updateInventory` 逐个更新
- 引用的行自动跳过更新

**删除逻辑**：
- 新行直接从本地删除
- 已存在的行调用 `deleteInventory` API
- 后端会检查引用状态，引用的行会返回错误

#### 4. 组件更新 (`InventoryEditTable.tsx`)

**移除全局只读模式**：
- 删除 `isReadOnly` prop
- 改为基于每行的 `isReferenced` 状态

**视觉区分**：
- 引用的行：灰色背景 (`bgcolor: 'action.hover'`)
- 未引用的行：白色背景 (`bgcolor: 'background.paper'`)

**字段禁用逻辑**：
```typescript
const isRowLocked = row.isReferenced === true;
<TextField disabled={isRowLocked} />
<Select disabled={isRowLocked} />
<IconButton disabled={isRowLocked || rows.length === 1} />
```

**提示信息**：
- 有引用行时显示：*"灰色背景的行表示已被订单引用，无法修改或删除"*
- 无引用行时隐藏提示

**保存按钮**：
- 禁用条件：`!isValidForSave() || !hasAnyEditableRow()`
- 确保至少有一行可编辑才能保存

## 数据流程

### 查询流程
```
前端加载进货单
  ↓
GET /api/inventory?purchaseId=X
  ↓
服务层查询 Inventory + OrderDetails
  ↓
计算每条记录的 IsReferenced
  ↓
返回带 isReferenced 的 DTO
  ↓
前端渲染（灰色=引用，白色=未引用）
```

### 更新流程
```
用户修改未引用的行
  ↓
点击保存
  ↓
PUT /api/inventory/{id}
  ↓
服务层检查 OrderDetails 引用
  ↓
如果被引用 → 抛出异常 → 400 错误
  ↓
如果未引用 → 更新成功 → 重新加载数据
```

### 删除流程
```
用户点击删除按钮
  ↓
DELETE /api/inventory/{id}
  ↓
服务层检查 OrderDetails 引用
  ↓
如果被引用 → 抛出异常 → 400 错误
  ↓
如果未引用 → 软删除 → 重新加载数据
```

## 边界情况处理

1. **全部行都被引用**：
   - 添加行按钮禁用
   - 保存按钮禁用
   - 删除按钮禁用
   - 所有字段禁用

2. **部分行被引用**：
   - 可以添加新行
   - 可以编辑/删除未引用的行
   - 引用的行显示灰色背景，字段禁用

3. **没有行被引用**：
   - 正常编辑模式
   - 不显示引用提示信息

4. **总金额验证**：
   - 仍然要求所有行的总金额等于进货总额
   - 引用的行也计入总金额

5. **并发安全**：
   - 后端在更新/删除时实时检查引用状态
   - 即使前端显示未引用，后端仍会验证

## 用户体验优化

1. **视觉反馈**：清晰的灰白色区分
2. **即时禁用**：引用的行所有交互元素立即禁用
3. **友好提示**：Alert 组件说明引用规则
4. **错误处理**：后端错误消息直接显示给用户
5. **数据同步**：保存/删除后自动刷新列表

## 技术要点

- **性能优化**：使用 `Distinct()` 和 `Contains()` 批量检查引用
- **类型安全**：TypeScript 类型定义确保数据一致性
- **错误边界**：前后端双重验证，防止误操作
- **状态管理**：React Hooks 管理复杂的编辑状态
- **UI 一致性**：Material-UI 组件统一样式

## 测试建议

1. **未引用的库存**：
   - 测试修改金额、数量等字段
   - 测试删除操作
   - 验证总金额计算正确

2. **已引用的库存**：
   - 验证所有字段禁用
   - 尝试删除应返回错误
   - 验证灰色背景显示

3. **混合状态**：
   - 添加新行到已有引用的进货单
   - 修改未引用行并保存
   - 验证引用行不受影响

4. **边界情况**：
   - 全部引用时的按钮状态
   - 总金额不匹配时的保存限制
   - 并发操作（一个用户创建订单的同时另一个用户编辑库存）
